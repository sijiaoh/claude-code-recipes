# 基础编程规则 (base.md)

本文件定义了适用于所有编程项目的核心规则和最佳实践，旨在显著提升 Claude Code 的编程性能和代码质量。

## 核心编程原则

### 1. 代码质量优先
- **可读性第一**: 代码是写给人看的，其次才是给机器执行的
- **简单胜过复杂**: 优先选择简单、直观的解决方案
- **一致性**: 保持代码风格、命名约定和架构模式的一致性
- **可维护性**: 编写易于理解、修改和扩展的代码

### 2. 渐进式开发
- **小步快跑**: 将大功能拆分为小的、可测试的单元
- **快速反馈**: 频繁运行测试和验证代码
- **迭代改进**: 持续重构和优化代码质量

## 测试驱动开发 (TDD)

### 测试优先原则
- **红-绿-重构循环**: 先写失败测试 → 编写最小实现 → 重构优化
- **测试覆盖率**: 关键业务逻辑必须有测试覆盖，目标覆盖率 ≥ 80%
- **测试金字塔**: 单元测试(多) → 集成测试(中) → 端到端测试(少)

### 测试质量标准
- **独立性**: 每个测试应该能够独立运行，不依赖其他测试
- **可重复**: 测试结果应该是确定的和可重复的
- **清晰命名**: 测试名称应该描述测试的业务场景
- **快速执行**: 单元测试应该能够快速执行（毫秒级）

### 测试组织结构
```
tests/
├── unit/           # 单元测试
├── integration/    # 集成测试
├── e2e/           # 端到端测试
└── fixtures/      # 测试数据和mock
```

## 代码可读性和质量

### 命名规范
- **变量名**: 使用描述性名称，避免缩写和单字符变量
- **函数名**: 使用动词开头，清楚表达函数功能
- **类名**: 使用名词，采用 PascalCase 命名
- **常量**: 使用大写字母和下划线

```python
# 好的命名示例
user_account_balance = calculate_account_balance(user_id)
MAX_RETRY_ATTEMPTS = 3

# 避免的命名
bal = calc(uid)
MAX_RETRY = 3
```

### 函数设计原则
- **单一职责**: 一个函数只做一件事
- **参数限制**: 函数参数不超过 3-4 个，多参数使用对象封装
- **返回值一致**: 函数的返回类型应该一致
- **副作用最小化**: 优先使用纯函数

### 代码结构
- **模块化**: 按功能划分模块，每个模块职责清晰
- **层次化**: 建立清晰的代码层次结构
- **接口抽象**: 定义清晰的接口和抽象层

## DRY 原则 (Don't Repeat Yourself)

### 消除重复代码
- **提取公共函数**: 将重复逻辑抽取为可复用函数
- **配置外部化**: 将硬编码值提取为配置文件或常量
- **模板和生成器**: 使用代码生成器处理重复模式

### 代码复用策略
- **工具函数库**: 建立项目通用工具函数库
- **组件化**: 将 UI 和业务逻辑组件化
- **设计模式**: 合理使用设计模式避免重复设计

### 配置管理
```python
# 集中配置管理
class Config:
    DATABASE_URL = os.getenv('DATABASE_URL', 'sqlite:///app.db')
    MAX_CONNECTIONS = int(os.getenv('MAX_CONNECTIONS', '10'))
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
```

## 性能优化

### 算法效率
- **时间复杂度**: 优先选择时间复杂度低的算法
- **空间复杂度**: 合理管理内存使用
- **数据结构**: 根据使用场景选择合适的数据结构

### 性能监控
- **性能测试**: 为关键路径编写性能测试
- **基准测试**: 建立性能基准，监控性能回归
- **性能分析**: 使用性能分析工具识别瓶颈

### 优化策略
- **缓存机制**: 合理使用缓存减少重复计算
- **异步处理**: 使用异步编程提升并发性能
- **数据库优化**: 优化查询语句和索引设计

## 错误处理和异常管理

### 异常处理原则
- **快速失败**: 尽早发现和报告错误
- **优雅降级**: 提供备选方案，避免系统崩溃
- **错误隔离**: 防止错误传播影响整个系统

### 错误处理最佳实践
```python
# 具体异常处理
try:
    result = process_data(data)
except ValidationError as e:
    logger.error(f"数据验证失败: {e}")
    return error_response("数据格式不正确")
except DatabaseError as e:
    logger.error(f"数据库操作失败: {e}")
    return error_response("系统暂时不可用")
```

### 日志记录
- **结构化日志**: 使用结构化格式记录日志
- **日志级别**: 合理使用 DEBUG、INFO、WARN、ERROR 级别
- **关键信息**: 记录足够的上下文信息用于调试

## 安全编程实践

### 输入验证
- **数据验证**: 严格验证所有外部输入
- **类型检查**: 使用类型提示和运行时类型检查
- **边界检查**: 验证数组索引和数值范围

### 安全编码
- **敏感信息**: 不在代码中硬编码密钥和密码
- **SQL 注入防护**: 使用参数化查询
- **XSS 防护**: 对用户输入进行转义处理

## 代码组织和架构

### 项目结构
```
project/
├── src/
│   ├── models/        # 数据模型
│   ├── services/      # 业务逻辑
│   ├── controllers/   # 控制器
│   └── utils/         # 工具函数
├── tests/
├── docs/
└── config/
```

### 依赖管理
- **依赖隔离**: 明确区分生产依赖和开发依赖
- **版本锁定**: 使用锁文件固定依赖版本
- **依赖最小化**: 避免引入不必要的依赖

### 模块化设计
- **高内聚低耦合**: 模块内部高度相关，模块间依赖最小
- **接口设计**: 定义清晰的模块接口
- **依赖注入**: 使用依赖注入提高可测试性

## 文档化和注释

### 代码注释
- **为什么而注释**: 解释代码的意图和业务逻辑，而不是做什么
- **复杂逻辑**: 为复杂算法和业务规则添加注释
- **公共接口**: 为所有公共 API 添加文档注释

### 文档维护
- **README**: 每个项目都应有完整的 README 文档
- **API 文档**: 自动生成和维护 API 文档
- **架构文档**: 记录重要的架构决策和设计

## 工具和环境配置

### 开发工具
- **代码格式化**: 使用自动化格式化工具
- **静态分析**: 使用 linter 和静态分析工具
- **类型检查**: 启用类型检查工具

### CI/CD 集成
- **自动化测试**: 所有提交都应通过自动化测试
- **代码质量检查**: 集成代码质量检查工具
- **自动化部署**: 建立自动化部署流程

### 版本控制最佳实践
- **提交信息**: 编写清晰、描述性的提交信息
- **分支策略**: 使用合适的分支策略（如 Git Flow）
- **代码审查**: 所有代码都应经过同行审查

### Git 提交规范
- **禁止使用命令替换**: 在 git commit 命令中不要使用 `$()` 或反引号进行命令替换
- **直接书写消息**: 使用 `git commit -m "消息内容"` 的简单形式
- **多行消息**: 如需多行消息，使用 `git commit` 进入编辑器或使用 `-m` 多次
```bash
# 正确方式
git commit -m "添加新功能"
git commit -m "标题" -m "详细描述"

# 避免使用
git commit -m "$(cat <<'EOF'...)"
git commit -m "`generate_message`"
```

## 持续改进

### 代码重构
- **定期重构**: 定期重构代码，消除技术债务
- **重构安全**: 依靠测试保证重构的安全性
- **小步重构**: 进行小规模、低风险的重构

### 学习和成长
- **技术追踪**: 跟踪相关技术的发展趋势
- **最佳实践**: 持续学习和应用行业最佳实践
- **团队分享**: 分享经验和知识，提升团队整体水平

---

*这些规则应该根据具体的编程语言和框架进行调整和扩展。*